\chapter{\IfLanguageName{dutch}{Stand van zaken}{State of the art}}%
\label{ch:stand-van-zaken}

% Welke termen en technologiën moet iemand kennen voor het onderzoek te snappen?
In dit hoofdstuk bespreken we de verschillende technologieën die betrekking hebben op dit onderzoek.
Deze literatuurstudie start met een omschrijving van het Angular-framework en hoe een Angular-project gestructureerd is.
Vervolgens wordt uitleg gegeven over de TypeScript-programmeertaal, specifiek hoe Angular deze gebruikt.
Ten slotte volgt een overzicht van verschillende gekende manieren om code automatisch aan te passen.

\section{Angular}
\label{ch:stand-van-zaken:angular}

% Wat is Angular?
Angular, ook wel Angular2 genoemd, is een user interface (UI) framework ontwikkeld door Google in 2016 \autocite{Cincovic2019}.
Het is gratis, open-source en wordt onderhouden door een diverse groep van ontwikkelaars.
% Waarvoor dient het?
Angular wordt gebruikt voor het maken van single-page webapplicaties die zowel client- als server-side gerenderd kunnen worden.
% Hoe maakt het een UI?
Voor het opbouwen van een UI in Angular worden ``componenten'' gebruikt.
% Wat is een component in Angular?
Een component binnen Angular wordt door \textcite{Kaufman2016} omschreven als een zelfstandig en herbruikbaar bouwblok.
Componenten encapsuleren de bedrijfslogica, structuur en stijl van een deel van de UI.
Het combineren van verschillende componenten laat toe om complexe UI's te maken.

% Hoe werkt het?
Angular is een opinionated framework.
\textcite{Parker2017} defineert een framework als opinionated als het de ontwikkelaar aanstuurt om op een specifieke manier te te werken.
Opinionated frameworks houden zich aan strikte conventies die dicteren hoe een project is opgesteld en geschreven.
% Wat kan het?
Het Angular-framework komt ingebouwd met verschillende functionaliteiten die de ontwikkeling van een applicatie aansturen \autocite{Wilken2018}.
Zoals eerder besproken maakt Angular gebruik van componenten voor het bouwen van een UI.
Verder komt het met functies die toelaten om unittests te schrijven voor deze componenten.
Angular heeft een collectie van command line (CLI) tools die de ontwikkelaars helpt bij het maken van een applicatie, bijvoorbeeld het genereren van een blanco component met bijhorende testen in één commando.
Verder komt het met een eigen Hyper Text Transfer Protocol (HTTP) client voor een applicatie te verbinden met een backendservice over het internet.

% Hoe is een Angular-project gestructureerd?
Angular is gebaseerd op TypeScript en gebruikt dit in combinatie met andere technologieën.
In een Angular-project zijn de volgende bestanden terug te vinden:
\begin{itemize}
  \item TypeScript: de TypeScript-programmeertaal wordt gebruikt voor de implementatie van de bedrijfslogica en testen.
  \item HTML: HTML wordt gebruikt om de achterliggende structuur van de UI te omschrijven. 
    In de context van Angular-componenten wordt hiernaar verwezen als een ``template''.
  \item CSS: CSS wordt gebruikt om de visuele representatie van de UI te omschrijven
  \item JSON: JSON wordt gebruikt voor het configureren van Angular en TypeScript.
\end{itemize}

\section{TypeScript}
\label{ch:stand-van-zaken:typescript}

% Waarom is dit relevant?
Om de broncode van een Angular-applicatie te begrijpen, moeten we de taal kennen waarin deze geschreven is.
% Wat is TypeScript?
TypeScript is een programmeertaal ontwikkeld door Microsoft in 2012.
\textcite{Bierman2014} omschrijft TypeScript als een extensie van JavaScript die een statisch typesysteem toevoegt.
Om TypeScript-code te gebruiken, moet deze eerst gecompileerd worden naar JavaScript.
TypeScript is een multiparadigm-programmeertaal. 
Het ondersteunt verschillende programmeerstijlen zoals: functioneel, procedureel, objectgeoriënteerd, \dots.

% Hoe maakt Angular gebruik van TypeScript?
Angular gebruikt TypeScript op een objectgeoriënteerde manier.
Een Angular-component is een TypeScript-klasse waar de ``@Component''-decorator boven de klasdeclaratie wordt meegegeven \autocite{Wilken2018}.
% Hoe worden HTML en CSS binnen Angular gebruikt?
Via deze decorator wordt de bedrijfslogica van de klasse gelinkt met de bijbehorende HTML en CSS.
Codefragment \ref{cf:component-declaration} illustreert hoe deze syntax eruitziet.

% Hoe ziet dit er uit?
\begin{listing}
  \begin{minted}{ts}
    import { Component } from '@angular/core';
    
    @Component({
      selector: 'my-component',
      templateUrl: './my-component.html',
      styleUrl: './my-component.css',
    })
    export class MyComponent {}
  \end{minted}
  \caption[Voorbeeld Angular component]{Voorbeeld van hoe een Angular component gedeclareerd wordt in TypeScript.}
  \label{cf:component-declaration}
\end{listing}

% Moet ik nog iets weten?
Angular gebruikt nog meerdere verschillende decorators, maar ``@Component'' is vrijwel de meest voorkomende.
TypeScript en Angular zijn uitgebreide thema's.
Hier hebben we de belangrijkste onderwerpen omschreven die nodig zijn om dit onderzoek te begrijpen.
In de volgende sectie bespreken we welke manieren bestaan om dit soort code automatisch aan te passen.

\section{Automatisch refactoren}
\label{ch:stand-van-zaken:refactoring}

% Wat is refactoren?
Refactoren, zoals omschreven door \textcite{Kaur2016}, is het proces om de broncode van een applicatie te passen zonder de functie te veranderen.
Het doel van refactoren is om de interne structuur van een applicatie te verbeteren.
% Wat betekend dit voor deze casus?
Concreet betekent ``verbeteren'' voor deze casus dat de applicatie up-to-date is en de conventies blijft volgen van de laatste nieuwe Angular-versie.

% Welke manieren bestaan er?
De studie door \textcite{Hodovychenko2025} vergelijkt de verschillende manieren om het refactoringproces te automatiseren.
In hun studie worden de manieren onderverdeeld in de volgende categorieën:
\begin{itemize}
  \item Toolgebaseerd: manuele of semi-automatische technieken ingebouwd in Integrated Development Environments (IDE's).
  \item Algorithmisch: regel-, patroon- of graaf-gebaseerde algoritmen.
  \item AI-gebaseerd: machine- of deep learning-modellen.
\end{itemize}
De volgende secties van het onderzoek geven concrete voorbeelden voor elke categorie.
Per voorbeeld worden inzichten gegeven in de werking en de voor- en nadelen.

\subsection{Zoek \& vervang}
\label{ch:stand-van-zaken:refactoring:find-and-replace}

% Waarom is dit relevant?
Eén van de simpelste vormen van toolgebaseerd refactoren is de zoek- en vervangfunctie.
Zoals de naam het zegt, zoekt dit naar instanties van een bepaalde sequentie van karakters in een tekst om deze vervolgens te vervangen.

% Wat is find & replace?
De simpelste vorm zoekt op basis van een woord of een vaste sequentie van karakters.
Meer complexe implementaties maken gebruik van reguliere expressies (regex).
% Hoe werkt dit?
Regex, als omschreven door \textcite{Goyvaerts2006}, is een speciale sequentie van karakters die een zoekpatroon omschrijft.
Het laat toe om naar complexe patronen in een tekst te zoeken.

% Wat zijn de voordelen?
Zoek- en vervangfuncties hebben meerdere voordelen.
Deze functies worden in veel applicaties gebruikt, zoals webbrowsers, tekstverwerkers, IDE's, \dots.
De meeste programmeertalen hebben functies om dit te implementeren, zowel tekst- als regex-gebaseerd.

% Wat zijn de nadelen?
Zoek- en vervangfuncties gebruiken op code is niet zonder nadelen.
Omdat het enkel zoekt op tekst, heeft het geen vat op de syntax of de semantiek van de programmeertaal.
% Wat is syntax?
De syntax omschrijft de structuur en volgorde van verklaringen in de programmeertaal.
% Wat is semantiek?
De semantiek daarentegen omschrijft de betekenis achter deze structuur en verklaringen.
% Wat heeft dit te maken met de nadelen?
Hierdoor is het mogelijk om ongewenste aanpassingen uit te voeren op de broncode.
Bijvoorbeeld: stel dat er twee klassen zijn met de naam A en B, en dat beide een methode foo bevatten.
Als we alle instanties van de methode foo in klasse A willen veranderen naar bar met behulp van zoek- en vervangfuncties, zullen alle instanties van foo in klasse B ook vervangen worden.

% Zijn er nog nadelen?
Hoewel het theoretisch mogelijk zou zijn om een reguliere expressie te schrijven die met deze specifieke syntax rekening houdt, zijn hier verschillende praktische problemen mee.
Uit de studie door \textcite{Michael2019} blijkt dat regexes moeilijk leesbaar, vindbaar, valideerbaar en documenteerbaar zijn.

\subsection{Language server}
\label{ch:stand-van-zaken:refactoring:lsp}

% Wat is een LSP?
Het Language Server Protocol (LSP) is een open protocol ontwikkeld door Microsoft voor Visual Studio Code.
Code editors en IDE's gebruiken LSP's om te communiceren met een language server \autocite{Bork2023}.
Een language server is een programma dat programmeertaalspecifieke functionaliteiten aanbiedt, zoals: automatisch aanvullen van code, code-diagnostiek, code-navigatie, \dots.
% Waarom is dit relevant?
Sinds de ontwikkeling van het LSP is het de facto standaard geworden om deze functies te implementeren in code-editors en IDE's.

% Wat is het LSP gebaseerd refactoren?
Voor dit onderzoek zijn de TypeScript en Angular language servers relevant.
% Wat kan de TypeScript LSP?
Volgens de \textcite{TypeScriptLS2025} biedt de TypeScript language server functies aan die broncode aanpassen, zoals: verwijderen van ongebruikte variabelen, organiseren van imports, verwijderen van ongebruikte imports, \dots.
% Wat kan de Angular LSP?
De Angular language server focust volgens de \textcite{AngularLS2025} op automatisch aanvullen en diagnostiek voor Angular-specifieke syntax in HTML.

% Wat zijn de voordelen?
Het voordeel van language servers is dat ze vat hebben op de specifieke syntax van de programmeertaal.
In combinatie met een zoek- en vervangfunctie kunnen we gericht code aanpassen.
En omdat language servers komen met code-diagnostiek, is het mogelijk om na een verandering direct fouten in de syntax op te sporen.

% Wat zijn de nadelen?
Language servers zijn echter niet perfect.
Ze hebben vat op de syntax, maar niet op de semantiek van de applicatie.
Verder zijn we gelimiteerd aan de functies van de language server.
Nieuwe functies implementeren, hoewel mogelijk, is niet praktisch.
Hoewel het de facto standaard in code-editors en IDE's is, blijft dit een zeer niche domein.
Een grondige kennis van het LSP is nodig om een language server aan te spreken of uit te breiden.

\subsection{Compiler}
\label{ch:stand-van-zaken:refactoring:compiler}

% Wat is compiler-gebaseerd refactoren?
De studie door \textcite{Wright2013} presenteert een tool voor het refactoren van grote C++ broncodes bij Google.
% Hoe werkt dit?
Deze tool maakt gebruik van de Clang C++ compiler om broncode om te zetten naar een Abstract Syntax Tree (AST) en zo de code te doorlopen met vat op de syntax.
Een AST, als omschreven door \textcite{Sun2023}, is een datastructuur die de structuur en syntax van een stuk code weergeeft.
Dezelfde bron noemt ATS's een fundamentele eigenschap van code.
Om deze reden wordt deze datastructuur vaak gebruikt om codegerelateerde problemen op te lossen.
Figuur \ref{fig:ast-preview} geeft een vereenvoudigde representatie van hoe een AST van een stuk TypeScript code eruit ziet.

\begin{figure}
  \centering
  \includegraphics[width=0.8\textwidth]{simple_ast_preview.png}
  \caption[Vereenvoudigde AST]{\label{fig:ast-preview}Voorbeeld van een vereenvoudigde AST-representatie (rechts) van een stuk TypeScript-code (links).}
\end{figure}

% Waarom is dit relevant?
Herinner dat Angular gebaseerd is op TypeScript en dat TypeScript gecompileerd moet worden.
De TypeScript compiler kan programmatisch aangesproken worden met de TypeScript compiler API.
Een studie door \textcite{Reid2023} gebruikt de TypeScript compiler voor het opsporen van foutieve code-elementen, met positieve resultaten.

% Wat zijn de voordelen?
Net zoals LSP's heeft de compiler vat op de syntax van de programmeertaal.
Op het vlak van correctheid is dit één van de meest betrouwbare opties.
Verder is de werking van AST's goed gedocumenteerd.
Tenslotte bestaan er voor TypeScript verschillende packages die helpen met het opstellen en doorlopen van een AST.

% Wat zijn de nadelen?
Maar net zoals LSP's heeft de compiler geen vat op de semantiek van de applicatie.
Werken met een AST vraagt kennis van boomstructuren en een goede kennis van de nuances van de syntax.

\subsection{Artificiële intelligentie}
\label{ch:stand-van-zaken:refactoring:ai}

% Waarom is dit relevant?
Met de recente opkomst in populariteit van artificiële intelligentie (AI) zijn reeds verschillende tools ontwikkeld om deze technologie in te zetten in het schrijven van code.

% Wat zijn de voordelen?
Een studie door \textcite{Poluai2025} toont aan dat automatisch coderefactoren met AI gebruikt kunnen worden om de performantie van applicaties te verbeteren.
Het toont aan dat deze AI-tools vat hebben op zowel de syntax als de semantiek van een applicatie.
Uit dezelfde studie blijkt dat het automatisatieproces correct was in 98\% van de gevallen.

% Wat zijn de nadelen?
AI-gebaseerd refactoren is veelbelovend, maar niet perfect.
De studie door \textcite{Hodovychenko2025} identificeert enkele praktische problemen met AI.
Om dit soort AI-tools te ontwikkelen, is een grote hoeveelheid kwalitatieve data nodig.
Verder is er een probleem met transparantie; de interne werking kan niet geverifieerd worden.

\subsection{Gekende problemen}
\label{ch:stand-van-zaken:refactoring:known-problems}

% Wat zijn de gekende problemen bij refactoren?

- Kan soms nieuwe bugs introduceren.







% Tip: Begin elk hoofdstuk met een paragraaf inleiding die beschrijft hoe
% dit hoofdstuk past binnen het geheel van de bachelorproef. Geef in het
% bijzonder aan wat de link is met het vorige en volgende hoofdstuk.

% Pas na deze inleidende paragraaf komt de eerste sectiehoofding.

% Dit hoofdstuk bevat je literatuurstudie. De inhoud gaat verder op de inleiding, maar zal het onderwerp van de bachelorproef *diepgaand* uitspitten. De bedoeling is dat de lezer na lezing van dit hoofdstuk helemaal op de hoogte is van de huidige stand van zaken (state-of-the-art) in het onderzoeksdomein. Iemand die niet vertrouwd is met het onderwerp, weet nu voldoende om de rest van het verhaal te kunnen volgen, zonder dat die er nog andere informatie moet over opzoeken \autocite{Pollefliet2011}.
% 
% Je verwijst bij elke bewering die je doet, vakterm die je introduceert, enz.\ naar je bronnen. In \LaTeX{} kan dat met het commando \texttt{$\backslash${textcite\{\}}} of \texttt{$\backslash${autocite\{\}}}. Als argument van het commando geef je de ``sleutel'' van een ``record'' in een bibliografische databank in het Bib\LaTeX{}-formaat (een tekstbestand). Als je expliciet naar de auteur verwijst in de zin (narratieve referentie), gebruik je \texttt{$\backslash${}textcite\{\}}. Soms is de auteursnaam niet expliciet een onderdeel van de zin, dan gebruik je \texttt{$\backslash${}autocite\{\}} (referentie tussen haakjes). Dit gebruik je bv.~bij een citaat, of om in het bijschrift van een overgenomen afbeelding, broncode, tabel, enz. te verwijzen naar de bron. In de volgende paragraaf een voorbeeld van elk.
% 
% \textcite{Knuth1998} schreef een van de standaardwerken over sorteer- en zoekalgoritmen. Experten zijn het erover eens dat cloud computing een interessante opportuniteit vormen, zowel voor gebruikers als voor dienstverleners op vlak van informatietechnologie~\autocite{Creeger2009}.
% 
% Let er ook op: het \texttt{cite}-commando voor de punt, dus binnen de zin. Je verwijst meteen naar een bron in de eerste zin die erop gebaseerd is, dus niet pas op het einde van een paragraaf.
% 
% \begin{figure}
%   \centering
%   \includegraphics[width=0.8\textwidth]{grail.jpg}
%   \caption[Voorbeeld figuur.]{\label{fig:grail}Voorbeeld van invoegen van een figuur. Zorg altijd voor een uitgebreid bijschrift dat de figuur volledig beschrijft zonder in de tekst te moeten gaan zoeken. Vergeet ook je bronvermelding niet!}
% \end{figure}
% 
% \begin{listing}
%   \begin{minted}{python}
%     import pandas as pd
%     import seaborn as sns
% 
%     penguins = sns.load_dataset('penguins')
%     sns.relplot(data=penguins, x="flipper_length_mm", y="bill_length_mm", hue="species")
%   \end{minted}
%   \caption[Voorbeeld codefragment]{Voorbeeld van het invoegen van een codefragment.}
% \end{listing}
% 
% \lipsum[7-20]
% 
% \begin{table}
%   \centering
%   \begin{tabular}{lcr}
%     \toprule
%     \textbf{Kolom 1} & \textbf{Kolom 2} & \textbf{Kolom 3} \\
%     $\alpha$         & $\beta$          & $\gamma$         \\
%     \midrule
%     A                & 10.230           & a                \\
%     B                & 45.678           & b                \\
%     C                & 99.987           & c                \\
%     \bottomrule
%   \end{tabular}
%   \caption[Voorbeeld tabel]{\label{tab:example}Voorbeeld van een tabel.}
% \end{table}

