%%=============================================================================
%% Methodologie
%%=============================================================================

\chapter{\IfLanguageName{dutch}{Methodologie}{Methodology}}%
\label{ch:methodologie}

%% TODO: In dit hoofstuk geef je een korte toelichting over hoe je te werk bent
%% gegaan. Verdeel je onderzoek in grote fasen, en licht in elke fase toe wat
%% de doelstelling was, welke deliverables daar uit gekomen zijn, en welke
%% onderzoeksmethoden je daarbij toegepast hebt. Verantwoord waarom je
%% op deze manier te werk gegaan bent.
%% 
%% Voorbeelden van zulke fasen zijn: literatuurstudie, opstellen van een
%% requirements-analyse, opstellen long-list (bij vergelijkende studie),
%% selectie van geschikte tools (bij vergelijkende studie, "short-list"),
%% opzetten testopstelling/PoC, uitvoeren testen en verzamelen
%% van resultaten, analyse van resultaten, ...
%%
%% !!!!! LET OP !!!!!
%%
%% Het is uitdrukkelijk NIET de bedoeling dat je het grootste deel van de corpus
%% van je bachelorproef in dit hoofstuk verwerkt! Dit hoofdstuk is eerder een
%% kort overzicht van je plan van aanpak.
%%
%% Maak voor elke fase (behalve het literatuuronderzoek) een NIEUW HOOFDSTUK aan
%% en geef het een gepaste titel.

% Wat gebeurt er in dit hoofdstuk?
In dit hoofdstuk maakt het onderzoek een beslissing over hoe de updater ontwikkeld wordt.
Deze beslissing is gebaseerd op de huidige stand van zaken en de noden van het bedrijf, zoals besproken in Hoofdstuk~\ref{sec:onderzoeksdoelstelling}.
Vervolgens wordt een proof of concept voor de updater ontwikkeld, samen met een testomgeving.
We bespreken de verschillende soorten aanpassingen die moeten gebeuren.
Geven een technisch overzicht van hoe de updater en testomgeving werkt.
En tenslotte wordt de effectiviteit van de updater opgemeten op de testomgeving.

\section{Plan van aanpak}
\label{ch:plan-van-aanpak}

% Hoe ziet de updater eruit?
Op basis van de huidige stand van zaken en de noden van het bedrijf, kiest het onderzoek voor het volgende plan van aanpak.
De updater wordt een collectie aan helperfuncties om een TypeScript command line applicatie te maken die onderliggend gebruikmaakt van zoek- en vervangfuncties op basis van regex in combinatie met de TypeScript compiler API.
Met de hulp van deze functies kan de ontwikkelaar programmatisch een updater maken, specifiek voor de nodige aanpassingen.

% Waarom een collectie van helperfuncties?
De nodige aanpassingen aan een applicatie zijn afhankelijk van de Angular versie.
Deze kunnen complex of simpel zijn.
Door de ontwikkelaar programmatisch de updater te laten configureren, is er een hoge flexibiliteit en uitbreidbaarheid van de updater.
De helperfuncties zorgen voor een hoge abstractie, wat toelaat om snel nieuwe updates te automatiseren.
Al dit geschreven in TypeScript, de programmeertaal waar de ontwikkelaars bekend mee zijn.

% Waarom TypeScript compiler API?
Om dit te implementeren wordt van de TypeScript compiler API gebruikgemaakt.
Door te programmeren op de compiler die normaal gebruikt wordt om de applicaties te compileren, krijgen we toegang tot dezelfde error detectie als de compiler.
Dit zorgt ervoor dat we nieuwe bugs snel en accuraat kunnen opsporen.
Verder is de interne werking, op basis van een AST, goed gedocumenteerd.
Tenslotte zijn we niet rechtstreeks gekoppeld aan Angular, enkel aan de programmeertaal.

% Waarom find & replace?
Om de implementatie voor de ontwikkelaar te vereenvoudigen, wordt de TypeScript compiler API gebruikt in combinatie met zoek- en vervangfuncties op basis van regex.

% Waarom een CLI-applicatie?
Angular komt reeds met CLI-tools; door de updater een CLI-applicatie te maken, past het in de huidige workflow.
Verder geeft dit de mogelijkheid om alle commando's samen te voegen in één script om de updater op meerdere projecten te laten uitvoeren.

\section{Angular aanpassingen}
\label{ch:angular-aanpassingen}

% Wat moet er veranderen aan de code?
Volgens de Angular update handleidling door \textcite{AngularUpdateGuide2025} zijn er in totaal 80 verschillende stappen nodig om een applicatie van v16 naar v20 te updaten.
% Wat doen we hiermee?
Dit onderzoek verdeelt deze stappen in verschillende ``categorieën''.
% Waarom verdelen in categorieën?
Deze onderverdeling geeft een beter overzicht van wat veranderd moet worden aan een Angular v16 applicatie.
Tenslotte geeft deze onderverdeling in combinatie met de resultaten van de updater een beter inzicht in waar de updater meer geschikt voor is.
% Wat zijn de categorieën?
De categorieën zijn opgesteld als volgt:
\begin{itemize}
  \item Veranderingen aan TypeScript.
  Dit is het grootste deel van alle aanpassingen.
  \item Veranderingen aan HTML templates.
  Dit zijn aanpassingen aan Angular specifieke code in HTML templates.
  \item Veranderingen aan unittesten.
  Dit zijn aanpassingen aan de unittests die afhankelijk zijn van Angular.
  \item Veranderingen aan JSON.
  Dit zijn aanpassingen aan JSON bestanden di de applicatie configureren.
  \item Uit te voeren commando's.
  Dit zijn commando's die uitgevoerd moeten worden in de command line.
  Meestal gaat dit om Angular packages of dependencies te updaten.
  \item Veranderingen aan syntax.
  Dit zijn aanpassingen aan syntax die de werking van de applicatie niet aanpassen.
  \item Veranderingen aan semantiek.
  Dit zijn aanpassingen in de achterliggende werking van Angular.
  En/of een verandering die ervoor zorgt dat de huidige werking van de applicatie moet veranderen.
  \item Veranderingen die niet van toepassing zijn. 
  Dit zijn aanpassingen aan functies toegevoegd na v16. 
  Het is dus onmogelijk dat de applicaties binnen Stater hiervan gebruikmaken.
\end{itemize}

% Kan een stap meerdere categorieën hebben?
Buiten de veranderingen dat niet van toepassing zijn, zijn deze categorieën niet wederzijds exclusief.
In één stap kunnen meerdere categorieën van toepassing zijn.
Een verandering kan impact hebben op zowel TypeScript als HTML, syntax als semantiek, \dots.

\section{Proof of concept}
\label{ch:proof-of-concept}

\subsection{Opzet updater}
\label{ch:proof-of-concept:opzet-updater}

% Wat maken we?
Om de updater te maken, voorziet het onderzoek van verschillende helperfuncties om de implementatie te vereenvoudigen.
% Wat gebruiken we hiervoor?
Deze helperfuncties maken gebruik van de ts-morph package.
ts-morph is een open-source package ontwikkeld door \textcite{Sherret2025}.
Het is een wrapper bovenop de TypeScript Compiler API die het makkelijker maakt om de AST te navigeren en te manipuleren.
% Waarom nog een laag hierbovenop?
Onze helperfuncties dienen als een extra laag hierbovenop.
Het doel hiervan is om een eenvoudige syntax te creëren, specifiek naar de noden van de updater.
% Wat gebeurt er in dit hoofdstuk?
We beginnen met een omschrijving van de helperfuncties.
Vervolgens geven we enkele voorbeelden van hoe deze functies samen gebruikt worden om een aanpassing aan broncode te automatiseren.

% Hoe vinden we de juiste nodes?
De eerste functie in codefragment~\ref{cf:find-nodes} helpt om de AST op een uniforme manier te navigeren.
Het doorloopt de AST vanaf een gegeven node.
Onderliggend gebruikt het een diepte eerst in orde zoek algoritme.
De parameters van deze functie specificeren twee callbackfuncties.
De eerste is een predicaat dat nagaat of een node voldoet aan een bepaalde omschrijving.
Indien dit waar is, wordt de tweede callbackfunctie opgeroepen, die vervolgens een bepaalde operatie uitvoert op deze node.
De helperfunctie geeft het aantal nodes terug dat aan het predicaat voldoet.
Dit maakt het mogelijk om deze functie als een predicaat te mee te geven.

\begin{listing}
  \begin{minted}{ts}
    /**
     * Finds the number of nodes that match the predicate in the given AST.
     *
     * @param {Node} root - The root node of the tree.
     * @param {(node: Node) => boolean | number} predicate - Callback function that evaluates each node.
     * @param {(node: Node) => void} onMatch - Callback function called if a node matches the predicate.
     */
    export function findNodes(
      root: Node,
      predicate: (node: Node) => boolean | number,
      onMatch: (node: Node) => void,
    ): number {
      let matches = 0;
      root.forEachDescendant((node) => {
        if (predicate(node)) {
          matches += 1;
          onMatch(node);
        }
      });
      return matches;
    }
  \end{minted}
  \caption[Doorloop AST]
    {
      Helperfunctie die de AST vanaf een gegeven node doorloopt.
      Op basis van de callbackfuncties kunnen gericht aanpassingen uitgevoerd worden op de AST.
    }
  \label{cf:find-nodes}
\end{listing}

Codefragment~\ref{cf:get-ancestor} omschrijft een ander manier om de AST te navigeren.
Hier doorlopen we de AST van een gegeven node terug naar de root van de AST.
De functie roept zichzelf recursief op tot de gewenste diepte bereikt is of de node geen ouder bevat.

\begin{listing}
  \begin{minted}{ts}
    /**
     * Gets the n'th ancestor of a node.
     *
     * @param {Node} node - The current node.
     * @param {number} count - The distance of the ancestor to the current node.
     */
    export function getAncestor(node: Node, count: number): Node | undefined {
      const parent = node.getParent();
      if (count <= 1 || !parent) return parent;
      return getAncestor(parent, --count);
    }
  \end{minted}
  \caption[Vind voorouder]{Helperfunctie die de n'de voorouder van een AST node teruggeeft.}
  \label{cf:get-ancestor}
\end{listing}

% Hoe impelmentere we find & replace?
De rest van de helperfuncties zijn predicaten voor codefragment~\ref{cf:find-nodes}.
Startend met codefragment~\ref{cf:contains-pattern}.
Deze helperfunctie gaat na of de tekstrepresentatie van een AST-node een gegeven regexpatroon bevat.
De tekstrepresentatie van een node is simpelweg hoe een stuk code eruitziet in de broncode.
Bijvoorbeeld, deze functie oproepen op de root node van een AST is hetzelfde als zoeken naar een patroon in het eigenlijke bestand.
Wordt de functie opgeroepen op een node die een klassedeclaratie voorstelt, is dit hetzelfde als zoeken naar een patroon in deze klasse.
Houd er rekening mee dat de tekstrepresentatie van een node ook de tekstrepresentatie bevat van alle kinderen.

\begin{listing}
  \begin{minted}{ts}
    /**
     * Checks if the text of a node contains a given pattern.
     *
     * @param {Node} node - The node to check.
     * @param {string} pattern - The pattern to check against.
     */
    export function containsPattern(node: Node, pattern: string): boolean {
      const matches = node.getText().match(pattern);
      return matches !== null && matches.length > 0;
    }
  \end{minted}
  \caption[Bevat patroon]
    {
      Helperfunctie die nagaat of een patroon terug te vinden is in de tekstrepresentatie van een AST-node.
    }
  \label{cf:contains-pattern}
\end{listing}

% Hoe vinden we de laatste instantie van een patroon?
Codefragment~\ref{cf:last-instance-in-tree} is een extensie op functie~\ref{cf:contains-pattern}.
Hier gaan we na of de gegeven node de laatste instantie van een patroon bevat in de AST.
Concreet kijkt de functie of de huidige node, en geen enkele van de kinderen, het patroon bevat.

\begin{listing}
  \begin{minted}{ts}
    /**
     * Checks if a node contains the last occurance of a given string in it's own subtree.
     *
     * @param {Node} node - The node to check.
     * @param {string} pattern - The pattern to check against.
     */
    export function lastInstanceInTree(node: Node, pattern: string): boolean {
      const matchesCurrent = containsPattern(node, pattern);
      const matchesChild = node.forEachChild((child) =>
        containsPattern(child, pattern),
      );
      return matchesCurrent && !matchesChild;
    }
  \end{minted}
  \caption[Bevat laatste instantie van patroon]
    {
      Helperfunctie die nagaat of een node de laatste instantie van een patroon bevat in de AST.
    }
  \label{cf:last-instance-in-tree}
\end{listing}

% Zijn er nog abstracte functies?
Alle functies tot nu toe waren tamelijk abstract en kunnen voor meerdere doeleinden gebruikt worden.
Nu volgen enkele functies die specifiek één doel hebben.
% Hoe vinden we de scope van een node?
De eerste van deze functies in codefragment~\ref{cf:in-scope-of} gaat na of een node in een bepaalde scope ligt.
We doen dit door recursief het syntaxtype van de ouder te vergelijken tot een match is gevonden of de node geen ouder bevat.
ts-morph evalueert het syntaxtype aan de hand van de ``SyntaxKind'' enumeratie.
Voorbeelden van syntaxtype zijn: bestanden, importdeclaraties, klassedeclaraties, expressies, decorators, keywords, \dots.
Als een node de syntaxtype matcht, dan wordt deze node teruggegeven.

\begin{listing}
  \begin{minted}{ts}
    /**
     * Checks if a node is in a certain scope.
     * Returns the first node that matches the given scope, otherwise undefined.
     *
     * @param {Node} node - The node to check.
     * @param {SyntaxKind} kind - The kind of the scope.
     */
    export function inScopeOf(node: Node, kind: SyntaxKind): Node | undefined {
      const parent = node.getParent();
      if (!parent) return undefined;
      if (parent.getKind() === kind) return parent;
      return inScopeOf(parent, kind);
    }
  \end{minted}
  \caption[In scope van]{Helperfunctie die nagaat of een AST node in een bepaalde scope zit.}
  \label{cf:in-scope-of}
\end{listing}

% Hoe vinden we het type van de node?
Codefragment~\ref{cf:has-type} definieert een helperfunctie om het type van een node terug te vinden.
Dit doen we door de tekstrepresentatie van het type te vergelijken met een gegeven regex patroon.
De tekstrepresentatie van het type is simpelweg hoe het type gebruikt wordt in de broncode.

\begin{listing}
  \begin{minted}{ts}
    /**
     * Checks if the type of the node matches the given pattern.
     *
     * @param {Node} node - The node to check.
     * @param {string} type - The pattern of the type.
     */
    export function hasType(node: Node, type: string): boolean {
      const matches = node
        .getType()
        .getText(undefined, TypeFormatFlags.InTypeAlias)
        .match(type);
      return matches !== null && matches.length > 0;
    }
  \end{minted}
  \caption[Heeft type]{Helperfunctie die nagaat of een AST node een bepaald type heeft.}
  \label{cf:has-type}
\end{listing}

% Hoe vinden we het type van het object dat de node aanspreekt?
De laatste helperfunctie in codefragment~\ref{cf:accessedFrom} dient om na te gaan of een node toegankelijk is vanaf een bepaald type.
Deze functie kijkt of de gegeven node aangesproken wordt vanuit een object.
Indien dit zo is, vergelijken we het type van dit object via de functie in codefragment~\ref{cf:has-type}.

\begin{listing}
  \begin{minted}{ts}
    /**
     * Checks if a node is accessed from a certain type.
     *
     * @param {Node} node - The node to check.
     * @param {string} type - The pattern of the type.
     */
    export function accessedFrom(node: Node, type: string): boolean {
      const accessProp = node.getParentIfKind(SyntaxKind.PropertyAccessExpression);
      if (!accessProp) return false;
      return hasType(accessProp.getExpression(), type);
    }
  \end{minted}
  \caption[Opgeroepen vanuit]{Helperfunctie die nagaat of een AST node opgeroepen wordt vanuit een bepaald type.}
  \label{cf:accessed-from}
\end{listing}

\subsection{Opzet testomgeving}
\label{ch:proof-of-concept:opzet-testomgeving}

\subsection{Updater evaluatie}
\label{ch:proof-of-concept:updater-evaluatie}

