%%=============================================================================
%% Methodologie
%%=============================================================================

\chapter{\IfLanguageName{dutch}{Methodologie}{Methodology}}%
\label{ch:methodologie}

%% TODO: In dit hoofstuk geef je een korte toelichting over hoe je te werk bent
%% gegaan. Verdeel je onderzoek in grote fasen, en licht in elke fase toe wat
%% de doelstelling was, welke deliverables daar uit gekomen zijn, en welke
%% onderzoeksmethoden je daarbij toegepast hebt. Verantwoord waarom je
%% op deze manier te werk gegaan bent.
%% 
%% Voorbeelden van zulke fasen zijn: literatuurstudie, opstellen van een
%% requirements-analyse, opstellen long-list (bij vergelijkende studie),
%% selectie van geschikte tools (bij vergelijkende studie, "short-list"),
%% opzetten testopstelling/PoC, uitvoeren testen en verzamelen
%% van resultaten, analyse van resultaten, ...
%%
%% !!!!! LET OP !!!!!
%%
%% Het is uitdrukkelijk NIET de bedoeling dat je het grootste deel van de corpus
%% van je bachelorproef in dit hoofstuk verwerkt! Dit hoofdstuk is eerder een
%% kort overzicht van je plan van aanpak.
%%
%% Maak voor elke fase (behalve het literatuuronderzoek) een NIEUW HOOFDSTUK aan
%% en geef het een gepaste titel.

% Wat gebeurt er in dit hoofdstuk?
In dit hoofdstuk maakt het onderzoek een beslissing over hoe de updater ontwikkeld wordt.
Deze beslissing is gebaseerd op de huidige stand van zaken en de noden van het bedrijf, zoals besproken in Hoofdstuk~\ref{sec:onderzoeksdoelstelling}.
We bespreken de verschillende soorten aanpassingen die moeten gebeuren om een Angular applicatie van v16 naar v20 te updaten.
Vervolgens bespreken we de proof of concept.
Hoe de updater geëvalueerd zal worden aan de hand van een testomgeving.
Wat de updater kan en doet.
En tenslotte de opstelling van deze testomgeving.
In Hoofdstuk~\ref{ch:proof-of-concept} wordt de technische uitwerking van de updater in meer detail besproken.

\section{Plan van aanpak}
\label{ch:plan-van-aanpak}

% Hoe ziet de updater eruit?
Op basis van de huidige stand van zaken en de noden van het bedrijf, kiest het onderzoek voor het volgende plan van aanpak.
We ontwikkelen een collectie aan helperfuncties om een TypeScript command line applicatie te maken die onderliggend gebruikmaakt van zoek- en vervangfuncties op basis van regex in combinatie met de TypeScript compiler API.
Met de hulp van deze functies kan een ontwikkelaar programmatisch een updater maken.

% Waarom een collectie van helperfuncties?
De nodige aanpassingen aan een applicatie zijn afhankelijk van de Angular versie.
Deze kunnen complex of simpel zijn.
Door de ontwikkelaar programmatisch de updater te laten configureren, is er een hoge flexibiliteit en uitbreidbaarheid van de updater.
De helperfuncties zorgen voor een extra abstractie laag, wat toelaat om snel nieuwe updates te automatiseren.
Al dit geschreven in TypeScript, de programmeertaal waar de ontwikkelaars bekend mee zijn.

% Waarom TypeScript compiler API?
Om dit te implementeren wordt van de TypeScript compiler API gebruikgemaakt.
Door te programmeren op de compiler die normaal gebruikt wordt om de applicaties te compileren, krijgen we toegang tot dezelfde error detectie als de compiler.
Dit zorgt ervoor dat we nieuwe bugs snel en accuraat kunnen opsporen.
Verder is de interne werking, op basis van een AST, goed gedocumenteerd.
Een basiskennis van boomstructuren is wel vereist om hiermee vlot aan de slag te gaan.
Tenslotte zijn we niet rechtstreeks gekoppeld aan Angular, enkel aan de programmeertaal.

% Waarom find & replace?
Om de implementatie voor de ontwikkelaar te vereenvoudigen, wordt de TypeScript compiler API gebruikt in combinatie met zoek- en vervangfuncties op basis van regex.

% Waarom een CLI-applicatie?
Angular komt reeds met CLI-tools; door de updater een CLI-applicatie te maken, past het in de huidige workflow.
Verder geeft dit de mogelijkheid om alle commando's samen te voegen in één script om de updater op meerdere projecten te laten uitvoeren.

\section{Angular aanpassingen}
\label{ch:angular-aanpassingen}

% Wat moet er veranderen aan de code?
Volgens de Angular update handleidling door \textcite{AngularUpdateGuide2025} zijn er in totaal 80 verschillende stappen nodig om een applicatie van v16 naar v20 te updaten.
% Wat doen we hiermee?
Dit onderzoek verdeelt deze stappen in verschillende ``categorieën''.
% Waarom verdelen in categorieën?
Deze onderverdeling geeft een beter overzicht van wat veranderd moet worden aan een Angular v16 applicatie.
Tenslotte geeft deze onderverdeling in combinatie met de resultaten van de updater een beter inzicht in waar de updater meer geschikt voor is.
% Wat zijn de categorieën?
De categorieën zijn opgesteld als volgt:
\begin{itemize}
  \item Veranderingen aan TypeScript.
  Dit is het grootste deel van alle aanpassingen.
  \item Veranderingen aan HTML templates.
  Dit zijn aanpassingen aan Angular specifieke code in HTML templates.
  \item Veranderingen aan unittesten.
  Dit zijn aanpassingen aan de unittests die afhankelijk zijn van Angular.
  \item Veranderingen aan JSON.
  Dit zijn aanpassingen aan JSON bestanden die de applicatie configureren.
  \item Uit te voeren commando's.
  Dit zijn commando's die uitgevoerd moeten worden in de command line.
  Meestal gaat dit om Angular packages of dependencies te updaten.
  \item Veranderingen aan syntax.
  Dit zijn aanpassingen aan syntax die de werking van de applicatie niet aanpassen.
  \item Veranderingen aan semantiek.
  Dit zijn aanpassingen in de achterliggende werking van Angular.
  En/of veranderingen die ervoor zorgen dat de huidige werking van de applicatie moet veranderen.
  \item Veranderingen die niet van toepassing zijn. 
  Dit zijn aanpassingen aan functies toegevoegd na v16. 
  Het is dus onmogelijk dat de applicaties binnen Stater hiervan gebruikmaken.
\end{itemize}

% Kan een stap meerdere categorieën hebben?
Buiten de veranderingen dat niet van toepassing zijn, zijn deze categorieën niet wederzijds exclusief.
In één stap kunnen meerdere categorieën van toepassing zijn.
Een verandering kan impact hebben op zowel TypeScript als HTML, syntax als semantiek, \dots.

\section{Opzet proof of concept}
\label{ch:opzet-proof-of-concept}

\subsection{Opzet testomgeving}
\label{ch:opzet-proof-of-concept:opzet-testomgeving}

% Wat is de test opgeving?
Om de effectiviteit van de updater te meten, zet dit onderzoek een testomgeving op.
De testomgeving is een applicatie gemaakt met Angular v16.
Het bestaat uit verschillende klasse en componenten specifiek geschreven met code dat moet veranderen in de update naar v20.
De applicatie is enkel syntactisch correct, verder heeft het geen doel.
Dit wil zeggen dat het enkel moet kunnen compileren zonder fouten, meer niet.
Er is bewust gekozen geen verdere semantiek aan de testomgeving te koppelen, omdat de huidige aanpak er geen rekening mee kan houden.

% Waarvoor dient het?
Dit onderzoek kiest ervoor om de effectiviteit van de updater te testen in een gecontroleerde omgeving om een totaalbeeld te krijgen van alle stappen.
In de praktijk is het niet zeker of een Angular applicatie alle code gebruikt dat aangepast wordt in de updates.
Het opzetten van een testomgeving geeft de mogelijkheid om een ruimer beeld te schetsen van wat mogelijk is met de updater.

% Hoe werd het opgesteld?
Het volgende proces wordt gehanteerd in het opstellen van de testapplicatie.
We doorlopen de Angular update handleidling van \textcite{AngularUpdateGuide2025} en evalueren elke stap of deze in aanmerking komt voor automatisatie.
Zoals eerder besproken zijn niet alle stappen aanpassingen aan TypeScript bestanden.
Verder is de aard van de verandering belangrijk.
De updater kan syntax interpreteren, maar geen semantiek.
Tabel~\ref{tab:opzet-testomgeving} geeft een overzicht van welke soort veranderingen in de testomgeving opgenomen worden.
\begin{table}
  \centering
  \begin{tabular}{p{0.24\textwidth}|p{0.22\textwidth}|p{0.46\textwidth}}
    \toprule
    \textbf{Soort verandering} & \textbf{In testomgeving} & \textbf{Reden} \\
    \midrule
    \multicolumn{3}{c}{\textbf{Bestandstype waar de verandering plaatsvindt}} \\
    \hline
    In HTML/JSON                        & Nee & De updater heeft geen vat op HTML/JSON. \\
    \hline
    In TypeScript                       & Ja  & De updater is gemaakt om TypeScript syntax te interpreteren. We voorzien een codefragment waarvan we weten dat het geüpdatet moet worden. \\
    \hline
    In TypeScript \& HTML/JSON          & Ja  & De updater heeft geen vat op HTML/JSON maar wel op TypeScript. We voorzien een codefragment waarvan we weten dat het geüpdatet moet worden. \\
    \hline
    \multicolumn{3}{c}{\textbf{Aard van de verandering}} \\
    \hline
    Aan semantiek                       & Nee & De updater heeft geen vat op semantiek. Dit soort aanpassingen zijn afhankelijk van hoe een applicatie Angular gebruikt. \\
    \hline
    Aan syntax                          & Ja  & De updater is gemaakt om TypeScript syntax te interpreteren. We voorzien een codefragment waarvan we weten dat het geüpdatet moet worden. \\
    \hline
    Aan syntax \& semantiek             & Ja  & De updater heeft geen vat op semantiek, maar wel op de syntax. We voorzien een codefragment waarvan we weten dat het geüpdatet moet worden. \\
    \hline
    \multicolumn{3}{c}{\textbf{Randgevalen}} \\
    \hline
    CLI-operaties                       & Nee & Voor deze stappen is geen nood aan een speciaal stuk code. \\
    \hline
    Functionaliteiten toegevoegd na v16 & Nee & Het is onmogelijk dat deze functionaliteiten gebruikt worden in de applicaties van Stater. \\
    \bottomrule
  \end{tabular}
  \caption[Opzet testomgeving]{
    \label{tab:opzet-testomgeving}
    Omschrijft welke stappen uit het updateproces al dan niet opgenomen worden in de testopgeving.
    Een stap wordt opgenomen in de testomgeving indien deze voldoet aan het bestandstype en de aard van de verandering.
  }
\end{table}
Voor elke verandering opgenomen in de testomgeving voorzien we een codefragment dat geüpdatet moet worden.
Alle codefragmenten zijn semi-realistisch en volgen de Angular best-practices waar mogelijk.
Tenslotte geven we per codefragment minstens één stuk code mee dat gelijkaardig is aan de code die veranderd moet worden.
Dit dient als controle om na te gaan of de updater specifiek genoeg ingesteld is.

\subsection{Opzet updater}
\label{ch:opzet-proof-of-concept:opzet-updater}

% Hoe wordt de updater geëvalueerd?
Dit onderzoek stelt een updater op die de testapplicatie van Angular v16 tot v20 autonoom tracht te updaten waar mogelijk.
Buiten de updates uitvoeren zal deze updater bijhouden wat het kan en niet kan.
Elke stap in het updateproces wordt manueel gecategoriseerd volgens de categorieën besproken in Hoofdstuk~\ref{ch:angular-aanpassingen}.
De updater probeert voor elk codefragment in de testapplicatie de nodige aanpassingen te detecteren en vervolgens te automatiseren.

% Woe wordt detecteer-/automatiseerbaarheid geëvalueerd?
Om een beter overzicht te krijgen van de capaciteiten van de updater worden detectie en automatisatie elk onderverdeeld in drie categorieën: niet, deels en volledig.
Niet detecteer-/automatiseerbaar zijn aanpassingen die niet autonoom uitvoerbaar zijn.
Dit kan zijn door de limitaties van de updater of de complexiteit van de aanpassing.
Dit onderzoek beschouwt een aanpassing als te complex indien er nood is om meer dan één AST te doorlopen om de aanpassing te detecteren.
Per TypeScript bestand behoort één AST.
Indien er meer dan één AST doorlopen moet worden, betekent dit dat de aanpassing betrekking heeft op meerdere bestanden binnen de applicatie.
Deels detecteer-/automatiseerbaar zijn aanpassingen die enkel deels autonoom uitvoerbaar zijn.
Bijvoorbeeld een functie die een nieuwe naam en extra parameters krijgt.
De naam kunnen we automatisch veranderen, maar de extra parameters moeten handmatig ingevuld worden, omdat ze afhankelijk zijn van de context.
Daarom kunnen uit de automatisatie van deze aanpassingen compiler errors ontstaan.
Volledig detecteer-/automatiseerbaar zijn aanpassingen die autonoom uitvoerbaar zijn.
Hier kan de aanpassing volledig autonoom gedetecteerd en/of uitgevoerd worden zonder compiler errors te veroorzaken.

% Hoe maken we de updater?
Om de updater te maken, voorziet het onderzoek verschillende helperfuncties om de implementatie te vereenvoudigen.
% Wat gebruiken we hiervoor?
Deze helperfuncties maken gebruik van de ts-morph package.
ts-morph is een open-source package ontwikkeld door \textcite{Sherret2025}.
Het is een wrapper bovenop de TypeScript Compiler API die het mogelijk maakt een TypeScript project om te zetten naar een AST.
Verder biedt het verschillende functies aan om een AST te navigeren en te manipuleren.
% Waarom nog een laag hierbovenop?
Onze helperfuncties vormen een extra laag hierbovenop.
Het doel hiervan is om een eenvoudige syntax te creëren, specifiek naar de noden van de updater.

\subsection{Evaluatie updater}
\label{ch:opzet-proof-of-concept:evaluatie-updater}

% Hoe evalueren we de updater?
Om de correctheid van de updater te testen, stelt dit onderzoek een controleomgeving op.
De controleomgeving is opgesteld door de testomgeving handmatig te updaten naar v20.
We evalueren de updater door de output te vergelijken met de controleomgeving.
Deze vergelijking gebeurt door alle TypeScript bestanden van beide projecten in te lezen en karakter per karakter te vergelijken.
Tabel~\ref{tab:evaluatie-updater} geeft een overzicht van hoe de vergelijking in werking treedt.
\begin{table}
  \centering
  \begin{tabular}{l|p{2.2cm}|p{2.2cm}|l}
    \toprule
    & \multicolumn{3}{l}{\textbf{Toegewezen automatiseerbaarheid}} \\
    \hline
    \textbf{Conditie} & \textbf{Volledig} & \textbf{Deels} & \textbf{Niet} \\
    \hline
    output = controle      & Waar & Fout & Fout \\
    output \neq{} controle & Fout & Waar & Waar \\
    \bottomrule
  \end{tabular}
  \caption[Evaluatie updater]{
    \label{tab:evaluatie-updater}
    Omschrijft wanneer de output van de updater correct of foutief is.
    De automatiseerbaarheid wordt tijdens het updateproces toegewezen per stap. 
    Een stap is volledig of deels automatiseerbaar als we weten dat er code aangepast is.
  }
\end{table}

