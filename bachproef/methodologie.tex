%%=============================================================================
%% Methodologie
%%=============================================================================

\chapter{\IfLanguageName{dutch}{Methodologie}{Methodology}}%
\label{ch:methodologie}

%% TODO: In dit hoofstuk geef je een korte toelichting over hoe je te werk bent
%% gegaan. Verdeel je onderzoek in grote fasen, en licht in elke fase toe wat
%% de doelstelling was, welke deliverables daar uit gekomen zijn, en welke
%% onderzoeksmethoden je daarbij toegepast hebt. Verantwoord waarom je
%% op deze manier te werk gegaan bent.
%% 
%% Voorbeelden van zulke fasen zijn: literatuurstudie, opstellen van een
%% requirements-analyse, opstellen long-list (bij vergelijkende studie),
%% selectie van geschikte tools (bij vergelijkende studie, "short-list"),
%% opzetten testopstelling/PoC, uitvoeren testen en verzamelen
%% van resultaten, analyse van resultaten, ...
%%
%% !!!!! LET OP !!!!!
%%
%% Het is uitdrukkelijk NIET de bedoeling dat je het grootste deel van de corpus
%% van je bachelorproef in dit hoofstuk verwerkt! Dit hoofdstuk is eerder een
%% kort overzicht van je plan van aanpak.
%%
%% Maak voor elke fase (behalve het literatuuronderzoek) een NIEUW HOOFDSTUK aan
%% en geef het een gepaste titel.

% Wat gebeurt er in dit hoofdstuk?
In dit hoofdstuk maakt het onderzoek een beslissing over hoe de updater ontwikkeld wordt.
Deze beslissing is gebaseerd op de huidige stand van zaken en de noden van het bedrijf, zoals besproken in Hoofdstuk~\ref{sec:onderzoeksdoelstelling}.
Vervolgens wordt een proof of concept voor de updater ontwikkeld, samen met een testomgeving.
We bespreken de verschillende soorten aanpassingen die moeten gebeuren.
Geven een technisch overzicht van hoe de updater en testomgeving werkt.
En tenslotte wordt de effectiviteit van de updater opgemeten op de testomgeving.

\section{Plan van aanpak}
\label{ch:plan-van-aanpak}

% Hoe ziet de updater eruit?
Op basis van de huidige stand van zaken en de noden van het bedrijf, kiest het onderzoek voor het volgende plan van aanpak.
De updater wordt een collectie aan helperfuncties om een TypeScript command line applicatie te maken die onderliggend gebruikmaakt van zoek- en vervangfuncties op basis van regex in combinatie met de TypeScript compiler API.
Met de hulp van deze functies kan de ontwikkelaar programmatisch een updater maken, specifiek voor de nodige aanpassingen.

% Waarom een collectie van helperfuncties?
De nodige aanpassingen aan een applicatie zijn afhankelijk van de Angular versie.
Deze kunnen complex of simpel zijn.
Door de ontwikkelaar programmatisch de updater te laten configureren, is er een hoge flexibiliteit en uitbreidbaarheid van de updater.
De helperfuncties zorgen voor een hoge abstractie, wat toelaat om snel nieuwe updates te automatiseren.
Al dit geschreven in TypeScript, de programmeertaal waar de ontwikkelaars bekend mee zijn.

% Waarom TypeScript compiler API?
Om dit te implementeren wordt van de TypeScript compiler API gebruikgemaakt.
Door te programmeren op de compiler die normaal gebruikt wordt om de applicaties te compileren, krijgen we toegang tot dezelfde error detectie als de compiler.
Dit zorgt ervoor dat we nieuwe bugs snel en accuraat kunnen opsporen.
Verder is de interne werking, op basis van een AST, goed gedocumenteerd.
Tenslotte zijn we niet rechtstreeks gekoppeld aan Angular, enkel aan de programmeertaal.

% Waarom find & replace?
Om de implementatie voor de ontwikkelaar te vereenvoudigen, wordt de TypeScript compiler API gebruikt in combinatie met zoek- en vervangfuncties op basis van regex.

% Waarom een CLI-applicatie?
Angular komt reeds met CLI-tools; door de updater een CLI-applicatie te maken, past het in de huidige workflow.
Verder geeft dit de mogelijkheid om alle commando's samen te voegen in één script om de updater op meerdere projecten te laten uitvoeren.

\section{Angular aanpassingen}
\label{ch:angular-aanpassingen}

% Wat moet er veranderen aan de code?
Volgens de Angular update handleidling door \textcite{AngularUpdateGuide2025} zijn er in totaal 80 verschillende stappen nodig om een applicatie van v16 naar v20 te updaten.
% Wat doen we hiermee?
Dit onderzoek verdeelt deze stappen in verschillende ``categorieën''.
% Waarom verdelen in categorieën?
Deze onderverdeling geeft een beter overzicht van wat veranderd moet worden aan een Angular v16 applicatie.
Tenslotte geeft deze onderverdeling in combinatie met de resultaten van de updater een beter inzicht in waar de updater meer geschikt voor is.
% Wat zijn de categorieën?
De categorieën zijn opgesteld als volgt:
\begin{itemize}
  \item Veranderingen aan TypeScript.
  Dit is het grootste deel van alle aanpassingen.
  \item Veranderingen aan HTML templates.
  Dit zijn aanpassingen aan Angular specifieke code in HTML templates.
  \item Veranderingen aan unittesten.
  Dit zijn aanpassingen aan de unittests die afhankelijk zijn van Angular.
  \item Veranderingen aan JSON.
  Dit zijn aanpassingen aan JSON bestanden di de applicatie configureren.
  \item Uit te voeren commando's.
  Dit zijn commando's die uitgevoerd moeten worden in de command line.
  Meestal gaat dit om Angular packages of dependencies te updaten.
  \item Veranderingen aan syntax.
  Dit zijn aanpassingen aan syntax die de werking van de applicatie niet aanpassen.
  \item Veranderingen aan semantiek.
  Dit zijn aanpassingen in de achterliggende werking van Angular.
  En/of een verandering die ervoor zorgt dat de huidige werking van de applicatie moet veranderen.
  \item Veranderingen die niet van toepassing zijn. 
  Dit zijn aanpassingen aan functies toegevoegd na v16. 
  Het is dus onmogelijk dat de applicaties binnen Stater hiervan gebruikmaken.
\end{itemize}

% Kan een stap meerdere categorieën hebben?
Buiten de veranderingen dat niet van toepassing zijn, zijn deze categorieën niet wederzijds exclusief.
In één stap kunnen meerdere categorieën van toepassing zijn.
Een verandering kan impact hebben op zowel TypeScript als HTML, syntax als semantiek, \dots.

\section{Proof of concept}
\label{ch:proof-of-concept}

\subsection{Opzet updater}
\label{ch:proof-of-concept:opzet-updater}

Voor de updater te maken voorziet dit onderzoek verschillende helperfuncties om de implementatie te vereenvoudigen.
Deze helper functies maken gebruikt de ts-morph package.
ts-morph is een open-source TypeScript package ontwikkeld door \textcite{Sherret2025}.
Het is een wrapper bovenop de TypeScript Compiler API dat het makkelijker maakt op de AST te navigeren en te manipuleren.

\begin{listing}
  \begin{minted}{ts}
    /**
     * Finds the number of nodes that match the predicate in the given AST.
     *
     * @param {Node} root - The root node of the tree.
     * @param {(node: Node) => boolean | number} predicate - Callback function that evaluates each node.
     * @param {(node: Node) => void} onMatch - Callback function called if a node matches the predicate.
     */
    export function findNodes(
      root: Node,
      predicate: (node: Node) => boolean | number,
      onMatch: (node: Node) => void,
    ): number {
      let matches = 0;
      root.forEachDescendant((node) => {
        if (predicate(node)) {
          matches += 1;
          onMatch(node);
        }
      });
      return matches;
    }
  \end{minted}
  \caption[Doorloop AST]
    {
      Helperfunctie dat de AST vanaf een gegeven node doorloopt.
      Op basis van de callback functies kunnen gericht aanpassingen uitgevoerd worden op de AST.
    }
  \label{cf:find-nodes}
\end{listing}



\begin{listing}
  \begin{minted}{ts}
    /**
     * Checks if the text of a node contains a given pattern.
     *
     * @param {Node} node - The node to check.
     * @param {string} pattern - The pattern to check against.
     */
    export function containsPattern(node: Node, pattern: string): boolean {
      const matches = node.getText().match(pattern);
      return matches !== null && matches.length > 0;
    }
  \end{minted}
  \caption[Bevat patroon]
    {
      Helperfunctie die nagaat of een patrooon terug te vinden is in de tekst representatie van een AST node.
    }
  \label{cf:contains-pattern}
\end{listing}



\begin{listing}
  \begin{minted}{ts}
    /**
     * Checks if a node contains the last occurance of a given string in it's own subtree.
     *
     * @param {Node} node - The node to check.
     * @param {string} pattern - The pattern to check against.
     */
    export function lastInstanceInTree(node: Node, pattern: string): boolean {
      const matchesCurrent = containsPattern(node, pattern);
      const matchesChild = node.forEachChild((child) =>
        containsPattern(child, pattern),
      );
      return matchesCurrent && !matchesChild;
    }
  \end{minted}
  \caption[Bevat laatste instantie van patroon]
    {
      Helperfunctie die nagaat of een AST node de laatste instantie van een patroon bevat in de boomstructuur.
    }
  \label{cf:last-instance-in-tree}
\end{listing}



\begin{listing}
  \begin{minted}{ts}
    /**
     * Gets the n'th ancestor of a node.
     *
     * @param {Node} node - The root node.
     * @param {number} count - The distance of the ancestor to the root node.
     */
    export function getAncestor(node: Node, count: number): Node | undefined {
      const parent = node.getParent();
      if (count <= 1 || !parent) return parent;
      return getAncestor(parent, --count);
    }
  \end{minted}
  \caption[Vind voorouder]{Helperfunctie die de n'de voorouder van een AST node teruggeeft.}
  \label{cf:get-ancestor}
\end{listing}



\begin{listing}
  \begin{minted}{ts}
    /**
     * Checks if a node is in a certain scope.
     * Returns the first node that matches the given scope, otherwise undefined.
     *
     * @param {Node} node - The node to check.
     * @param {SyntaxKind} kind - The kind of the scope.
     */
    export function inScopeOf(node: Node, kind: SyntaxKind): Node | undefined {
      const parent = node.getParent();
      if (!parent) return undefined;
      if (parent.getKind() === kind) return parent;
      return inScopeOf(parent, kind);
    }
  \end{minted}
  \caption[In scope van]{Helperfunctie die nagaat of een AST node in een bepaalde scope zit.}
  \label{cf:in-scope-of}
\end{listing}



\begin{listing}
  \begin{minted}{ts}
    /**
     * Checks if the type of the node matches the given pattern.
     *
     * @param {Node} node - The node to check.
     * @param {string} type - The pattern of the type.
     */
    export function hasType(node: Node, type: string): boolean {
      const matches = node
        .getType()
        .getText(undefined, TypeFormatFlags.InTypeAlias)
        .match(type);
      return matches !== null && matches.length > 0;
    }
  \end{minted}
  \caption[Heeft type]{Helperfunctie die nagaat of een AST node een bepaalt type heeft.}
  \label{cf:has-type}
\end{listing}



\begin{listing}
  \begin{minted}{ts}
    /**
     * Checks if a node is accessed from a certain type.
     *
     * @param {Node} node - The node to check.
     * @param {string} type - The pattern of the type.
     */
    export function accessedFrom(node: Node, type: string): boolean {
      const accessProp = node.getParentIfKind(SyntaxKind.PropertyAccessExpression);
      if (!accessProp) return false;
      return hasType(accessProp.getExpression(), type);
    }
  \end{minted}
  \caption[Opgeroepen van]{Helperfunctie die nagaat of een AST node opgeroepen wordt vanuit een bepaald type.}
  \label{cf:accessed-from}
\end{listing}

\subsection{Opzet testomgeving}
\label{ch:proof-of-concept:opzet-testomgeving}

\subsection{Updater evaluatie}
\label{ch:proof-of-concept:updater-evaluatie}

